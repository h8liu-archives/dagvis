// Generated by CoffeeScript 1.8.0
(function() {
  var main;

  main = function() {
    var b, boxHeight, boxWidth, boxof, cmpNode, dat, esc, fromx, fromy, lab, layout, node, nodes, output, p, path, pathof, paths, svg, toNode, tox, toy, turnx, xgrid, xpush, ygrid, _i, _j, _k, _len, _len1, _len2, _ref;
    xgrid = 130;
    ygrid = 30;
    boxWidth = 120;
    boxHeight = 20;
    esc = function(name) {
      return name.replace(/\//g, '_');
    };
    boxof = function(name) {
      return "rect#" + esc(name);
    };
    pathof = function(from, to) {
      return "path#" + esc(from) + "-" + esc(to);
    };
    nodes = [];
    for (node in gostd) {
      dat = gostd[node];
      dat.name = node;
      nodes.push(dat);
    }
    cmpNode = function(a, b) {
      if (a.x < b.x) {
        return -1;
      }
      if (a.x > b.x) {
        return 1;
      }
      if (a.y < b.y) {
        return -1;
      }
      if (a.y > b.y) {
        return 1;
      }
      return 0;
    };
    nodes.sort(cmpNode);
    xpush = function() {
      var n, name, push, pushWorthy, revNodes, tryPush, xmax, _i, _j, _k, _l, _len, _len1, _len2, _len3;
      xmax = 0;
      for (_i = 0, _len = nodes.length; _i < _len; _i++) {
        dat = nodes[_i];
        if (dat.x > xmax) {
          xmax = dat.x;
        }
      }
      tryPush = function(name) {
        var out, sub, worthy, _j, _len1, _ref;
        node = gostd[name];
        if (node.x === xmax) {
          return {
            able: false,
            worthy: false
          };
        }
        worthy = false;
        _ref = node.outs;
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          out = _ref[_j];
          if (gostd[out].x > node.x + 1) {
            worthy = true;
            continue;
          }
          sub = tryPush(out);
          if (!sub.able) {
            return {
              able: false,
              worthy: false
            };
          }
          if (sub.worthy) {
            worthy = true;
          }
        }
        return {
          able: true,
          worthy: worthy
        };
      };
      pushWorthy = function(name) {
        var ret;
        ret = tryPush(name);
        return ret.worthy;
      };
      push = function(name) {
        var out, _j, _len1, _ref;
        node = gostd[name];
        _ref = node.outs;
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          out = _ref[_j];
          if (gostd[out].x > node.x + 1) {
            continue;
          }
          push(out);
        }
        node.newx = node.x + 1;
      };
      revNodes = nodes.slice().reverse();
      for (_j = 0, _len1 = revNodes.length; _j < _len1; _j++) {
        dat = revNodes[_j];
        name = dat.name;
        while (pushWorthy(name)) {
          for (_k = 0, _len2 = nodes.length; _k < _len2; _k++) {
            n = nodes[_k];
            n.newx = n.x;
          }
          push(name);
          for (_l = 0, _len3 = nodes.length; _l < _len3; _l++) {
            n = nodes[_l];
            n.x = n.newx;
          }
        }
      }
    };
    xpush();
    layout = function() {
      var col, cols, i, n, out, tak, taken, x, xmax, xmin, xthis, y, ymax, _i, _j, _k, _len, _ref, _ref1, _ref2;
      xmax = 0;
      ymax = 0;
      for (node in gostd) {
        dat = gostd[node];
        if (dat.x > xmax) {
          xmax = dat.x;
        }
        if (dat.y > ymax) {
          ymax = dat.y;
        }
      }
      taken = [];
      cols = [];
      for (i = _i = 0; 0 <= xmax ? _i <= xmax : _i >= xmax; i = 0 <= xmax ? ++_i : --_i) {
        taken.push({});
        cols.push([]);
      }
      for (node in gostd) {
        dat = gostd[node];
        cols[dat.x].push(dat);
      }
      for (x in cols) {
        col = cols[x];
        for (y in col) {
          dat = col[y];
          xthis = dat.x;
          xmax = dat.x;
          xmin = -1;
          _ref = dat.outs;
          for (_j = 0, _len = _ref.length; _j < _len; _j++) {
            out = _ref[_j];
            n = gostd[out];
            if (n.x > xmax) {
              xmax = n.x;
            }
            if (xmin === -1 || n.x < xmin) {
              xmin = n.x;
            }
          }
          tak = taken[xthis];
          y = 0;
          while (y in tak) {
            y = y + 1;
          }
          tak[y] = true;
          if (xmax - 1 > xthis) {
            for (i = _k = _ref1 = xthis + 1, _ref2 = xmax - 1; _ref1 <= _ref2 ? _k <= _ref2 : _k >= _ref2; i = _ref1 <= _ref2 ? ++_k : --_k) {
              taken[i][y] = true;
            }
          }
          dat.newy = y;
        }
      }
      for (node in gostd) {
        dat = gostd[node];
        dat.y = dat.newy;
      }
    };
    layout();
    svg = d3.select("svg#main");
    paths = [];
    for (node in gostd) {
      dat = gostd[node];
      _ref = dat.outs;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        output = _ref[_i];
        toNode = gostd[output];
        fromx = dat.x * xgrid + boxWidth;
        fromy = dat.y * ygrid + boxHeight / 2;
        tox = toNode.x * xgrid;
        toy = toNode.y * ygrid + boxHeight / 2;
        turnx = tox - 5;
        path = "M" + fromx + " " + fromy;
        path += " L" + turnx + " " + fromy;
        path += " L" + turnx + " " + toy;
        path += " L" + tox + " " + toy;
        paths.push({
          p: path,
          n: esc(node) + "-" + esc(output)
        });
      }
    }
    for (_j = 0, _len1 = paths.length; _j < _len1; _j++) {
      path = paths[_j];
      p = svg.append("path");
      p.attr("d", path.p);
      p.attr("class", "bg");
    }
    for (_k = 0, _len2 = paths.length; _k < _len2; _k++) {
      path = paths[_k];
      p = svg.append("path");
      p.attr("d", path.p);
      p.attr("id", path.n);
      p.attr("class", "dep");
    }
    for (node in gostd) {
      dat = gostd[node];
      b = svg.append("rect");
      b.attr("x", dat.x * xgrid);
      b.attr("y", dat.y * ygrid);
      b.attr("ry", 5);
      b.attr("ry", 5);
      b.attr("width", boxWidth);
      b.attr("height", boxHeight);
      b.attr("class", "box");
      b.attr("id", esc(node));
      lab = svg.append("text");
      lab.attr("x", dat.x * xgrid + boxWidth / 2);
      lab.attr("y", dat.y * ygrid + boxHeight / 2 + 4);
      lab.attr("class", "lab");
      lab.attr("id", "lab-" + name);
      lab.text(node);
      b.on("mouseover", (function() {
        var x;
        x = dat;
        return function(d) {
          var input, _l, _len3, _len4, _m, _ref1, _ref2;
          svg.selectAll("rect").attr("class", "box");
          svg.selectAll("path.dep").attr("class", "dep");
          svg.select(boxof(x.name)).attr("class", "box focus");
          _ref1 = x.ins;
          for (_l = 0, _len3 = _ref1.length; _l < _len3; _l++) {
            input = _ref1[_l];
            svg.select(boxof(input)).attr("class", "box in");
            svg.select(pathof(input, x.name)).attr("class", "dep in");
          }
          _ref2 = x.outs;
          for (_m = 0, _len4 = _ref2.length; _m < _len4; _m++) {
            output = _ref2[_m];
            svg.select(boxof(output)).attr("class", "box out");
            svg.select(pathof(x.name, output)).attr("class", "dep out");
          }
        };
      })());
    }
  };

  $(document).ready(main);

}).call(this);
